# Enigma Machine Simulation

## Опис проекту
Цей скрипт є програмною реалізацією спрощеної моделі шифрувальної машини "Енігма". 

### Головні відмінності від апаратної Енігми

Завдання навмисно спрощує історичну механіку машини, перетворюючи її на лінійний алгоритм. Основні архітектурні відмінності:

1. **Ротори статичні (Не обертаються):** В оригінальній Енігмі ротори фізично проверталися з кожним натисканням клавіші, постійно змінюючи електричний ланцюг. У цій програмі ротори є нерухомими таблицями підстановок (Look-Up Tables). Вони лише виконують послідовну заміну символів.
2. **Динаміка винесена в препроцесинг:** Оскільки ротори не крутяться, властивість поліалфавітності (зміна шифру для кожної наступної літери) досягається інакше. Перед тим як потрапити в ротори, символ проходить через математичний зсув (Caesar Shift), який залежить від початкового ключа та поточного індексу літери `i`.
3. **Відсутність рефлектора (Асиметричність):**
   Справжня Енігма мала рефлектор, який відбивав сигнал і пропускав його через ротори у зворотному напрямку. Це робило машину симетричною (одна й та сама операція і для шифрування, і для дешифрування). У нашому коді алгоритм лінійний: шифрування йде у прямому напрямку, а дешифрування вимагає виконання операцій у строго зворотному порядку (LIFO).

### 1. Блок динамічного зсуву (Dynamic Caesar Shift)
Виконує роль препроцесингу (при шифруванні) або постпроцесингу (при дешифруванні). Зсув є динамічним і залежить від початкового ключа та просторово-часової позиції символу в потоці.

Математична модель прямого перетворення:
$$K = (P + N + i) \pmod{26}$$
де:
* $P$ — базовий індекс поточного символу в стандартному алфавіті (0–25).
* $N$ — стартовий зсув (Initial Shift Key).
* $i$ — індекс позиції символу в повідомленні (Лічильник тактів).

### 2. Каскад роторів (Substitution Network / S-boxes)
Реалізований як послідовність статичних таблиць підстановок (Look-Up Tables). 
* **Шифрування (ENCODE):** Сигнал маршрутизується через ротори у прямому порядку: $Shift \to R_1 \to R_2 \to R_3$. Застосовується пряма індексація масивів пам'яті.
* **Дешифрування (DECODE):** Застосовується принцип LIFO. Сигнал проходить каскад у зворотному напрямку: $R_3 \to R_2 \to R_1 \to Inverse Shift$. Застосовується алгоритм пошуку за значенням (Reverse Lookup).

